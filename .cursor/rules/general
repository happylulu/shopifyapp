Thanks! I’ll create a one-page development guideline tailored for a **public embedded Shopify app** focused on **loyalty and rewards management**, using your full-stack TypeScript and Next.js setup with App Bridge v4, Polaris, Prisma, and GraphQL.

I’ll include best practices for app architecture, authentication, UI/UX consistency with Polaris, API management, and key considerations for App Store approval.

I’ll update you once it’s ready.


# Shopify Embedded Loyalty App – Development Guidelines

## App Structure & Modular Design

* **Organize your codebase** by feature and responsibility. Use Next.js 14 App Router with React 18 server components to separate concerns and keep sensitive operations (OAuth, API calls) on the server. For example, define modules for **auth**, **loyalty points**, **reward tiers**, etc., and create reusable components (points balance display, tier badges) to avoid duplication.
* **Global providers:** In your Next.js `app/layout.tsx`, wrap the app with required providers. Include the Shopify App Bridge React `<Provider>` (v4) for embedding, the Polaris `<AppProvider>` for UI consistency, and any state management providers (e.g. React Query’s `QueryClientProvider`). This ensures Shopify context (shop, host) and Polaris theming are available on every page.
* **TypeScript-first approach:** Use TypeScript across the stack for reliability. Leverage GraphQL Code Generator to auto-generate TypeScript types for Shopify GraphQL queries and mutations, ensuring compile-time checks. Keep your components focused and **modular** – a component should ideally handle one piece of UI or logic. Avoid monolithic files; instead, split into logical files (e.g. `components/LoyaltyPointsTable.tsx`, `lib/shopifyAPI.ts` for API calls, `services/loyalty.ts` for point calculations).
* **Prisma & database design:** Use Prisma ORM to manage your app’s data (e.g. storing customer point balances, reward definitions). During development use SQLite for simplicity; in production use PostgreSQL for scalability. Keep database schema migrations under version control. **Do:** design a clear data model for loyalty (tables for customers, point transactions, reward tiers) with relations (e.g. link customers by Shopify customer ID). **Don’t:** expose raw database queries in your UI code – keep data access in backend APIs or dedicated server utilities for security and maintainability.

## Authentication & Session Security

* **OAuth best practices:** Implement Shopify’s OAuth flow using the official Shopify API library (v9) to handle app installation and permission scopes. Store the **offline access token** (long-lived API token) securely on your backend once the merchant installs the app. Use this token for all Shopify API calls from your server. **Do:** encrypt tokens or store them in a secure database table accessible only by your backend. **Don’t:** expose this token on the frontend or in client-side code.
* **Session tokens (JWT):** Use Shopify App Bridge v4 to authenticate each request from your frontend to your backend. When the app loads, use App Bridge to retrieve a short-lived session token (JWT) and include it in the authorization header of API calls to your Next.js backend. This replaces third-party cookies (which are blocked in modern browsers). **Do:** verify the session token on every backend request using your app’s secret key (the Shopify API library can help with this verification). **Don’t:** rely on cookies for auth in an embedded app – Shopify **requires** JWT session tokens for embedded apps to ensure secure, seamless authentication.
* **Token exchange strategy:** Implement Shopify’s recommended token exchange if using direct API calls from frontend. For example, your backend can accept a session token and return a response using the stored offline token. This keeps the actual Shopify API calls server-side while the front end only handles the lightweight JWT. Ensure that all Next.js API routes that require auth call a helper to validate the token and load the session/shop context.
* **Security webhooks:** Implement the **App Uninstalled** webhook to know when a merchant uninstalls the app – in the handler, clean up any stored tokens or data as needed. Also register GDPR webhooks (customers/data\_request, customers/redact, shop/redact) if your app stores personal data (like customer info for loyalty) to comply with data deletion requests. Always verify HMAC signatures on incoming webhooks and requests from Shopify to ensure they are authentic.

## Polaris UI/UX Consistency

* **Use Shopify Polaris for UI:** Build your interface with Shopify Polaris React components to provide a familiar, merchant-friendly experience. Polaris components ensure your embedded app matches the Shopify admin look and feel. **Do:** use Polaris components (Page, Card, Form, DataTable, Toast, Modal, etc.) for common UI patterns instead of building custom UI from scratch. This maintains consistency and accessibility out of the box.
* **Tailwind CSS integration:** Tailwind can be used for utility-first styling, but use it mainly for layout or minor stylistic tweaks **in harmony** with Polaris. **Don’t:** override Polaris styles in a way that confuses the user (e.g. changing Polaris button colors outside of theming guidelines). Keep the design clean and uncluttered – follow Polaris design guidelines for spacing, typography, and component usage.
* **Responsive and accessible design:** Ensure your app works on various screen sizes, including the Shopify Mobile app (embedded webview). Polaris is responsive by default, but test key screens (e.g. loyalty program dashboard, points history) on smaller devices. Use Polaris accessibility features (proper labels, etc.) so that your app is usable with screen readers and meets Shopify’s accessibility standards.
* **Merchant-centric UX:** Design with the merchant in mind. Use clear language and Polaris’s empty state and skeleton components for loading states. **Do:** provide helpful feedback – e.g., show a Polaris Banner or Toast for success/failure of actions like “Points awarded” or error messages. **Don’t:** overwhelm the merchant with too many steps or technical jargon. The UI should make it obvious how to set up loyalty rules, view customer points, and redeem rewards. Keep primary actions prominent and use Polaris’s layout (like setting one primary button per page section for the main action).

## App Bridge v4 Integration

* **Initialize App Bridge correctly:** Use `@shopify/app-bridge-react` v4 to create the App Bridge `<Provider>` at the root of your app. Supply the `config={{ apiKey: SHOPIFY_API_KEY, host: hostParameter }}` (the `host` comes from the query param in the embedded URL). This ensures the Shopify admin loads your app inside an iframe with proper authorization. **Do:** utilize the App Bridge React hooks/components (e.g. `useAppBridge()` or `<TitleBar />, <Modal />` components) to create embedded UI elements like modals and title bars seamlessly.
* **Session Provider:** If available (as in Shopify’s Next.js app template), use a `<SessionProvider>` to automatically handle redirection to OAuth when a session is missing or expired. This uses App Bridge to kick off re-auth if needed, improving reliability. It’s an optional utility but recommended to manage session state.
* **App Bridge actions:** Leverage App Bridge actions for enhanced UX. For example, use **Modals** from App Bridge (or Polaris embedded modals) for confirmations, **Resource Picker** to let merchants select products (if needed for rewards), **Toast** notifications via App Bridge for global messages, and **Redirect** actions to navigate within Shopify (e.g., redirecting to the Discounts page or back to an order). These ensure the actions happen smoothly within the admin. **Don’t:** try to break out of the iframe or manipulate the parent window – always use App Bridge for any parent context changes (navigation, outside-iframe dialogs).
* **Routing and navigation:** With Next.js App Router, client-side navigation within your app should still inform Shopify’s admin. Use Polaris’s Link with a custom `linkComponent` or Next.js’s `<Link>` to navigate pages, and ensure App Bridge’s history is updated (Shopify’s App Bridge can automatically handle iframe height and navigation events if set up). **Do:** set `embedded_app_direct_api_access = true` in your Shopify app config (shopify.app.toml) to use direct API mode with App Bridge v4, allowing your front end to query your backend without a full page reload. This makes navigation faster and more app-like.
* **Performance considerations:** Include the Shopify App Bridge **script tag** in your HTML head as recommended, alongside the npm App Bridge. This enables Shopify’s performance tracking (Web Vitals) for your app. App Bridge v4 is optimized for faster loads, but you should also minimize App Bridge actions on initial load – load only necessary App Bridge features at start (e.g., maybe set up TitleBar) and defer others (like loading a Modal component) until needed to reduce overhead.

## Loyalty Program Features & Data Management

* **Points system design:** Implement a robust points calculation system. Typically, customers earn points for actions like purchases (e.g. X points per dollar spent) and possibly other activities (account creation, referrals, etc.). **Do:** use Shopify webhooks (orders paid, etc.) to automatically award points in real-time. For example, on an `orders/paid` webhook, calculate points based on order total and save a points transaction in your database. This decouples awarding logic from the front end and ensures no order is missed even if the merchant isn’t actively using the app.
* **Data storage and Shopify sync:** Store point balances and reward statuses in your app database (via Prisma models). To integrate with Shopify, you can also sync key info back to the store: for instance, store a customer metafield for current point balance or tier. This way, a merchant can see loyalty info on the Shopify Customer page, and it’s accessible if needed in other Shopify channels. Use the Shopify Admin GraphQL API to read/write metafields (scope `write_customers` required for customer metafields).
* **Reward tiers & redemption:** Define VIP tiers (e.g., Bronze, Silver, Gold) with clear criteria (such as reaching a points threshold or total spending). **Do:** allow merchants to configure these tiers and associated perks (like “Gold members get 1.5x points per purchase or special discounts”). Enforce these rules in your point calculation logic. For redemptions, consider allowing points-to-coupon conversions: e.g., a customer can redeem 100 points for a discount code. Utilize the Shopify Discounts API (GraphQL) to create discount codes on demand when the merchant approves a redemption.
* **UI for loyalty features:** Provide an intuitive dashboard in your app for merchants to monitor and manage the program. For example, show a summary (total members, points issued, points redeemed), and lists of customers with their point balances. Use Polaris data tables or resource lists for these. Include features like filtering (e.g., find a customer by name/email to adjust points) and editing (adjusting point balances manually if needed). **Don’t:** forget edge cases – handle point expiration (if the program has expiring points), refunds (possibly deduct points for returned orders), and multi-currency or tax considerations (decide if points are based on order subtotal, etc.).
* **Efficiency and scalability:** If the store is large (thousands of customers), avoid loading all customers at once. Use pagination and search in the UI, and maybe provide summary stats rather than heavy data dumps. In the backend, consider using batch operations or Shopify’s bulk GraphQL queries for large updates (Shopify allows bulk queries for long-running data pulls). Ensure your loyalty logic runs efficiently to not hit rate limits – e.g., when awarding points on orders, calculate quickly and use minimal API calls (one mutation to update a metafield or a single bulk mutation if awarding points to many customers at once for some reason).

## Shopify API (GraphQL) Best Practices

* **Use GraphQL for Shopify data:** Shopify has made GraphQL the preferred Admin API for new apps (new apps must use GraphQL after April 1, 2025). Use the Shopify GraphQL Admin API (through the official library or GraphQL request clients) for fetching and mutating shop data. GraphQL allows you to query exactly the fields you need, reducing data over-fetching. **Do:** design your queries to be efficient – for example, when fetching customers for the loyalty dashboard, query only the fields you need (name, email, tags or metafields for points) rather than the entire customer object.
* **Batch and cache requests:** Take advantage of Apollo Client or React Query caching. Use `React Query` for data fetching and caching on the frontend – e.g., cache the result of a “get customer points” query so that navigating back to the dashboard doesn’t refetch unnecessarily. When performing bulk operations (like updating points for many customers), consider Shopify’s Bulk Operations API (which is GraphQL-based) to run a single job instead of hundreds of API calls.
* **Handle API limits and errors:** Shopify GraphQL has a cost-based rate limiting. **Do:** check the `cost` in GraphQL responses and ensure your queries stay within reasonable bounds (avoiding very expensive queries in a single call). Implement retries with backoff for transient errors, and handle user-facing errors gracefully (e.g., show a Polaris Banner if an API call fails with a message). **Don’t:** spam the API with unthrottled calls – use webhooks or periodic syncs instead of frequent polling. For example, rather than polling for order updates to award points, rely on the webhook to notify you.
* **Secure API access:** All calls to Shopify should come from your backend using the stored access token (offline token). If you expose a GraphQL endpoint on your Next.js app (e.g., `/api/graphql` that proxies requests), **verify the session token** on those requests to ensure the caller is your app iframe and not an external attacker. Never trust `shop` identifiers or other params from the client without verification. Use Shopify’s Node library middlewares or custom logic to validate HMAC signatures on any incoming requests where applicable.
* **GraphQL Codegen & Apollo:** Use GraphQL Code Generator to create typed queries/mutations and even custom React hooks if desired. This not only helps catch errors but also speeds up development (you get auto-complete for query fields and input types). With Apollo Client in the frontend, you can integrate the codegen types for robust usage. If using Apollo, set up the Apollo client to point to your Next.js API proxy or directly to Shopify (with proper auth). If not using Apollo’s cache, React Query with a simple GraphQL fetch (using `graphql-request`) is perfectly fine and often simpler – just ensure consistent data fetching functions and error handling in one place.

## App Store Readiness (Security, Performance, UX, Scopes)

* **Security & privacy:** Follow Shopify’s security requirements closely. **Do:** ensure all endpoints in your app are secured – for example, Next.js API routes should check the session token or have middleware to require an active session. Sanitize any user inputs (though most input will be internal/admin, still avoid XSS by using React sanitization for any HTML). If your app stores personal data (e.g. customer info, emails for loyalty program), have a privacy policy and handle deletion requests via the GDPR webhooks. **Don’t:** log or store sensitive Shopify data unnecessarily. Only keep what you need for the loyalty program (e.g., customer IDs, points, maybe names/emails for display) and nothing more.
* **Minimal scopes:** Request only the API access scopes your app truly needs. For a loyalty app, common scopes would be `read_customers` (to read customer info, maybe needed for checking past orders via Customer -> orders connection), `write_customers` (if writing customer tags or metafields for points), `read_orders` (to award points based on orders), and possibly `write_discounts` (if creating discount codes for rewards). If you use Shopify ScriptTags or perform storefront actions, you might need `write_script_tags` or others – but avoid excessive scopes. **Don’t** ask for scopes like full `read_all_orders` (historical) unless absolutely required, as it adds friction. Each scope you request should be justified in your app listing to reassure merchants.
* **Performance optimizations:** A fast app is crucial for merchant experience and will be evaluated by Shopify. **Do:** load your app’s main page quickly by deferring non-critical data loading. For instance, load the overview stats first and lazy-load detailed tables or charts. Use Polaris Skeleton components to indicate loading content instead of showing a blank screen, so merchants get instant feedback. Bundle your app efficiently – remove unused dependencies, enable Next.js compression and modern image formats. Test your app with Shopify’s performance tools (Shopify’s Partner Dashboard may show Web Vitals metrics). Aim for a low Largest Contentful Paint (LCP) by keeping initial render light.
* **User experience & polish:** Ensure the app is intuitive and bug-free before submission. **Do:** provide a guided setup if necessary (for example, a brief onboarding explaining how to configure point rules and tiers). Use tooltips or help text (Polaris Info banners or Tooltips) to clarify complex features. Make sure to handle error states (e.g., if a Shopify API call fails or a webhook fails to register, inform the user with next steps or retry options). **Don’t:** leave broken links or placeholder content. Every visible part of the UI should be purposeful and working. Additionally, provide a support contact or FAQ link in the app (Shopify requires an easy way for merchants to get support).
* **Testing and QA:** Test the installation and uninstall flows thoroughly. When the merchant installs, does the OAuth redirect and token saving work every time? Test on multiple shops. After uninstalling, if they reinstall, ensure the flow still works (clean up old data if necessary on reinstall to avoid conflicts). Also test with different browsers and ensure session token auth works (especially Safari with ITP – session tokens solve this, but be sure your implementation is solid). Shopify’s review team will test your app for stability: any crashes or errors can lead to rejection, so handle all edge cases gracefully.
* **Compliance with Shopify guidelines:** Finally, review Shopify’s [App Design Guidelines](https://shopify.dev/docs/apps/design-guidelines) and \[App Store checklist]. Ensure your app follows them: consistent Polaris design, proper JWT usage, no prohibited practices (like using customer data outside app scope without permission), and a good overall experience. By adhering to best practices and focusing on security, performance, and usability, your loyalty & rewards app will be well-positioned for approval and success on the Shopify App Store.
